# Karma

Тестирование клиентского кода это отдельная головная боль. Полезность юнит тестирование доказана неоднократно.
Однако при разработке клиентского кода самым важным местом является взамисодействия пользователя с интерфейсом. И эта область сложно поддается тестированию.

Это существенно тормозит разработку, внеся какоето изменение мы вынуждены повторить все пользовательские действия чтобы убедится что ничего не сломалось. Мы считаем что тесты разработчиков не должны покрывать совершенно все возможные варианты использования контрола пользователем. Когда фиксится баг на этот случай заводится тест, чтобы при рефакторинге случайно не сломать.

Оснавная цель создателей `karma` дать разработчикам продуктивное тестовой окружение. Тестовое окружение которое не надо постоянно настраивать и конфигурировать, инстурмент который позволит разработчикам просто писать код и быстро получать обратную связь от их тестов.

Мы в компании используем `Karma`. `Karma` Это просто тест раннер, он не заствляет вас использовать какойто определенный фреймворк. Нравится писать тесты на `jasmine` - пишите. Нравится `Mocha` - ипользуйте его. У нас есть проекты использующие как `jsasmine` так и `mocha`. Главное это желание тестировать код.

Изначально разработчики `Karma` активно предлогали использовать для тестирования пользовательского взаимодействия `angular-scenario` который поддерживал базовый пользовательские взаимодйствия (ввод с клавиатуры, клики). Также `ng-scanario` дает возможность быстро, и что не маловажно, просто расширять DSL доступный для тестирования своим кодом.

Именно поэтому мы особо не спешим переходить на рекомендованный разработчикоми `Karma` новый `protractor` который использет селениум. Особого преимущества для нашего подхода к тестам он не дает.

В общем для наших компонентов мы пишем два вида тестов:
* юнит тесты для публично api и event api
* тесты для тестирования базового взаимодействия пользователя с контролами

В связи с тем что для некоторых вещей, сейчас приходится писать неоправдано много тестов для пользовательского взаимодействие, появляется желание сделать связь кода отвечающего за функционал с кодом отвечающего за представление и пользовательского взаимодействия слабее. Cделать логическое разделение кода для MVC.


