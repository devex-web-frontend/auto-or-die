## ☠ HTML ☠

### Статические прототипы

Мы в компании используем для разработки статические прототипы. Статические прототипы — это просто HTML-файлы, которые можно запустить на любой машине, на которой есть браузер. Не нужен ни сревер, ни сборка, ни деплой.

Плюсы такого подхода:
* Результат виден раньше. Цикл до первого отсмотра значительно сокращается: дизайнеры, аналитики, ПМы могут увидеть как будет выглядеть продукт сразу как только страницу сверстали и добавили немного JS. 
* Мы вообще отвязываемся от бэкенд технологии. Внутри команды мы можем использовать единообразный процесс вне зависимости от того, что это за проект. Да, конечно, кому-то придётся переводить статику в UiBinder, Freemarker или что-то ещё.
* Серверные pазработчики просто могут просто вставолять куски статической вёрстки в проект — в нём не будет дыр, и он будет выглядеть красиво.
 
### Адский код

Но есть и проблемы:
* либо мы полчаем неподдерживаемую портянку в несколько тысяч строк, с которой не каждый diff справится — что уж говорить о человеке;
* либо у нас много страничек, которые надо держать в соответствии друг с другом.

Получается, что статические прототипы не решают свою задачу^ не упрощают разработку, а наоборот усложняют её.

Но сдаваться рано! У нас есть генераторы статических сайтов.

Я знаю их несколько, мы для себя выбрали Assemble. Если вы знаете аналоги, готов с удовольствем обсудить их с вами после доклада.

### Assemble

Как я уже сказал, Assemble — это генератор статических сайтов. В качестве среды он использует Node.js, а в качестве шаблонного движка по умолчанию — Handlebars.


=====

Я хочу подробнее оставноиться на Assemble, поскольку он совсем мало освещён. Например, на Хабре про Jekyll что-то находится, а вот по запросу «assemble» получаем статьи про Assembl**y** и Assembl**er**.

### Assemble

Как я уже сказал, Assemble — это генератор статических сайтов. Написан под Node.js, в качестве движка по умолчанию использует Handlebars.

Assemble очень прост в работе — фактически у него всего несколько основных понятий. Если мы говорим о шаблонах — это layout, page, partial.

#### Layout

Файл, на основе которого генерятся страницы. Отличается от всех остальных тем, что в нём обязательно должна быть директива `{{> body}}` — то место, куда будет вставлено содержимое страницы.

Что ещё важно знать про лейауты:
* можно без них — если у вас одностраничное приложение, незачем оборачивать единственную страницу в лейаут
* могут быть вложенными — просто укажите, что у лейаута есть свой лейаут!

#### Page

Собственно, сама страница.

#### Partial

Любой кусок, который вы хотите вынести в отдельный шаблон. Можно ещё назвать словом include.

Вставляется с помощью директивы `{{> partial context}}`. Если контекст не передать, будет использован текущий. Если же контекст передать, то контекст, переданный в паршл будет урезан и по нему нельзя будет ходить с помощью `../`.

Мы не нашли никакого решения этой проблемы, поэтому написали два хелпера, которые дают нам способ обойти эту неприятность: один из них сохраняет глобальную область видимости, а другой вызывает паршлы с этой глобальной областью видимости.

#### Helper

Собственно, хелперы. API для них — это встроенный механизм Handlebars для расширения возможностей. У Assemble есть своя большая библиотека хелперов, но если там чего-то не хватает, всегда можно написать свой. Это не сложно.

Важно знать, что хелпер бывают простые (обычно возвращают строку) и блочные (что-то делают с шаблоном, который оборачивают).

#### Data

В качестве данных можно использовать JSON или YAML. Ещё есть очень удобный механизм YAML Front Matter, который позволяет задавать какие-то данные прямо в шаблоне страницы.

Кроме того, есть ряд встроенных переменных, таких как `pagename`, `filename`, `ext` и т.д.

#### Конфигурация

* Можно поменять шаблонный движок: из коробки работают Handlebars и swig, но можно написать свой
* Есть `postprocess`: можно, например, подправить пути к ресурсам
* Можно собирать не только HTML
