## ☠ Управление инструментами ☠

Мы автоматизировали разработку и тестирование, организацию кода и управление зависимостями. Тем не менее, процесс всё равно выглядит муторно.

Представим нормальную рабочую ситуацию: нужно добавить новый блок, в котором используется какой-то JS-контрол.
Для этого придётся:
* Подключить контрол с помощью `bower`, выкачать зависимости.
* Добавить блок с помощью `yo`.
* Запустить сборку и вотчер Assemble.
* Запустить сборку и вотчер Stylus.
* Запустить Karma в режиме вотчера.

Только потом можно приступать к разработке.

Ну ладно, разработчики люди бывалые, ко всему привыкли.
Но ведь и процесс сборки выглядит не лучше:
* Выкачать зависимости
* Запустить сборку Assemble
* Запустить сборку Stylus
* Прогнать тесты
* Запаковать результат в архив

Поглядев на это всё, можно сказать: «Какая же это автоматизация? Нужно обложиться терминальными окошками и постоянно в них все заглядывать на предмет ошибок».

Действительно, все эти инструменты по своему прекрасны, но весь этот зоопарк неплохо бы как-то организовать. Давайте этим и займёмся.

Чтобы всем было удобно, давайте опираться на два принципа:
* Единая среда
* Запуск задач — это API

Давайте по порядку. Не знаю, заметили ли вы, но мы постоянно упоминали Node.js. Это та самая единая среда: ведь крайне удобно, когда тебе надо поставить только один...

### Запуск задач — это API

Какое бы средство автоматизации вы не выбрали, у него должна быть одна точка входа. И раз уж наша единая среда — это Node.js, вполне логично, что такой точкой входа у нас является npm.

Другие команды или сервер непрерывной интеграции не обязаны ничего знать про то, что у вас там под капотом. Им достаточно установить Node.js + npm, глобальные Node-пакеты — и всё, можно в бой.

#### package.json/scripts

* `install` — помимо установки локальных Node-пакетов, устанавливает и bower-зависимости
* `test` — запускает тесты
* `build` — сборка проекта для продакшна

```
npm install
npm run build
```
И проект собран.

В общем-то если у вас проект небольшой, можно на этом и оставновиться. Npm-скрипты уже освобождают нам руки. Но если помимо удобства сборки, вам нужно ещё и удобство разработки, вам понадобится таск-раннер.

### Grunt или gulp? 

Без разницы! Выбирайте тот, который лучше подходит для вашего проекта, с которым вам удобнее работать, который вам больше по душе, наконец!

Мы выбрали Grunt.

#### Gruntfile.js
* `install` — да, мы стартуем Bower из Grunt
* `test` — стартуем Karma
* `build` — собирает проект

Эти таски отлично матчатся на npm-скрипты.

Конечно, у нас есть и другие: можно поднять две-сервер, собрать отдельно html, css и js, в каких-то проектах может понадобиться отдельно собрать какого-то вендора и т.д.

Не знаю, заметили ли вы, но у нас нет тасков `build_dev` или `test_watch` — это потому что Grunt, как и многие терминальные приложения умеет принимать ключи, начинающиеся с минус-минус. Это важный момент, о котором не стоит забывать, потому что вам это поможет держать свой таск-раннер конфиг в чистоте.

### Show me the money!
Относитесь к запуску задач как к API: дайте клиентам одну точку входа и простые способа запуска задач. Тогда никому за пределами вашей команды не придётся знать ничего лишнего. Понятно, что все девелоперские задачи должны быть скрыты уже на другом уровне.
