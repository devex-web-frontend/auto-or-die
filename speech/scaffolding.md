# Организация кода

### Разделяй и властвуй


> расказать про профит от шаблонной структуры. Скзаать что есть обратная сторона. Расплата может быть слишком дорогой

Чтобы писать поддерживаемую верстку в первую очередь нужно граммотно разбивать стили.
Самое главное не стоит это делать интуитивно. Лучше выработать ряд соглашений по организации файловой структуры ваших стилей. Однако поддержание различных соглашений может вызывать кучу негативных моментов.

Чтобы не говорить о сверических конях в вакууме, попробую обьяснить на примере соглашений принятых в нашей команде.

Серебренной пули как организовывать ваши стили - не существует. На вашу файловую структуру должны оказывать влияние идеология разработки и специфика ваших проектов.

В качестве исходных данных мы имели:
* класснеймы по БЭМу
* мультискиннинг (проекты для которых в любой момент моежт смениться цветовая схема или появится новая)


Спустя некоторое время мы выработали следующее соглашение для организации кода:
* для каждого скина мы разбиваем стили на `blocks` и `looks`
* на **каждый** блок мы заводим свою папочку с минимальной структурой
* крупные модификаторы выносим в отдельные файлы в рамках блока
 
Шаблонные операции:

1. Создать фаловую раскладку для `blocks` и `looks`
2. зарегистрировать новые файлы и папки в соответсвующих `index.styl`
3. толкнуть все новые файлы в VCS

И впринципи это не такая уж и большая проблема для простого проекта, однако для активного скинящегося проекта поддержка подобных соглашений может стать очень дорогой. Да и выполнение подобных соглашении оставляет в разработчике все меньше и меньше человечности. При оперделенном стечении обстоятельств разработчики могут тупо забивать на соглашения что возвращает нас к захлвамлению кода.


> Идея график: по оси икс количство скинов по левой оси y время (затраты на шаблонные операции) по правой оси y состояние разработчика (от нормального до зомби) на прмиере себя

Принятие подобных соглашений это всегда сделка: возможность быстрого внесения изменений за счет дополнительной траты времени на шаблонные операции по созданию файлов и папок.

Причем чем сильнее дробление тем проще и быстрее вносить изменения, но тем больше времени отнимают различные шаблонные операции по поддержанию файловой структуры.



### Что нужно от инструмента
Чтобы все были счастливы необходимо свести к минимуму времязатраты на шаблонные операции и сделать это время постоянным (не зависящим от сложности проекта)

Решение своих проблем мы нашли в скаффоолдере.
Скаффолдер - это CLI утилита (обычно идет с фреймворком), которая по запросу пользователя (разработчика) генерирует шаблонный код и структуру файлов необходимую для поддержания работы фреймворка.

Мы всетаки Front-End разработчики и разбираться как писать CLI интсрументы не хотелось. Хотелосьбы просто описать сценарий генерации нашей базовой структуры и получить в свое распоряжение простой и умный скаффолдер.

И тут нам на глаза попался инструмент Yo, который позиционируется как скаффолдер, однако он скорее фреймворк для создания скаффолдеров.

Что дает Yo:

* механизм запуска генрации
* процессинг файлов
* взаимодействие с пользователем (по средствам inquirer.js)

и так как все это работает под nodejs можно реализовать сколь угодно сложный воркфлоу.













***********

###Поддерживаемая верстка
###### (просто слайд с заголовком)

Оба рассмотренных Антоном инструмента помогают решить важную проблему, они помогают создавать поддерживаемую верстку.

### Постепенное решение проблем
###### [лестница, лестница хогвартса]

Процесс внедрения всех новых инструментов у нас был постепенный, то есть: 

* надоело выискивать нужно свойство среди толпы префиксных свойств и писать мокрые селекторы. Решили использовать stylus
* Затем начали напрягать огромные файлы статических прототипов, надоело щаниматься копипастой внутри проекта. Решили ввести шаблонизацию и использовать генератор сайтов `assemble`.

Вносить изменения стало проще, но всеравно осталось ощущение какогото беспорядка.

### Идеологические проблемы
* именование файлов (такие вещи должны быть строго зафиксированы, все люди разные)
* организация файлов
* выработать best-practices (чтобы повысить фактор ожидаемости кода: не искать "где может быть определено то или иное правило", не писать дублирующих селекторов).

И если с best practices все понятно, все соглашения должны быть где-то зафиксированы и контролироваться при помощи code review. То на именовании и организации файлов стоит остановиться по-подробнее.

### Организация кода
Чтобы писать поддерживаемый код, организация всех файлов проекта должна быть логична, все файлы должны быть "чистыми" и разложены по своим местам.
Бекенд разработчики это отлично понимают в отличие от фронтенд разработчиков.

### Цитата
Вот, например, цитата David Heinemeier Hansson (автора популярного фреймфорка RoR) из его [выступления](http://www.rubyinside.com/dhh-keynote-streaming-live-from-railsconf-2011-right-here-right-now-4769.html) на RailsConf 2011:

> I think empty folders and empty files are two of the pivotal innovations in Rails that have encouraged us to write clean applications since the framework appeared

### Организация кода

Все то же самое справедливо и для фронтенд ресурсов.
И если рельсовое приложение состоит из моделей, контроллеров, вьюшек хелперов и прочих рельсовых составляющих, то верстка по БЭМу состоит тупо из блоков. Именно эту идею мы и решили заложить в файловую структуру нашей верстки.

### Наш подход

```
styls
  |--workset
  | |--index.styl
  | |--someAwesomeBlock
  | | |--index.styl
  | | |--someAwesomeBlock.styl
  | | |--someAwesomeBlock--element.styl
  | | |--someAwesomeBlock-modification.styl
  | | |--someAwesomeBlock-superModification.styl
  |--colors
  | |--index.styl
  | | |--someAwesomeBlock.styl
  | | |--someAwesomeBlock--element.styl
  | | |--someAwesomeBlock-modification.styl
  | | |--someAwesomeBlock-superModification.styl
```

Несложно заметить, что соблюдение подобной файловой структуры порождает большое количество рутинных операций, которые с большой долей вероятности будут отнимать много времени, сбивать с мысли и, в конце концов, просто бесить.

Чтобы завести новый блок:

1. Завести в папке `workset` файл `index.styl` для регистрации необходимых для файлов стилей
2. Завести в папке `workset` файл именем блока (`someAwesomeBlock.styl`)
3. Зарегистрировать в `workset/someAwesomeBlock/index.styl` файл блока
4. Зарегистрировать в `workset/index.styl` папку блока
5. Сделать все то же самое для блока в папке `colors`
6. Завести соответствующий партивал
7. Толкнуть все созданные файлы в VCS

Всю эту последовательность операций трудозатратно выполнять даже для создания блоков в простых проектах, но еще более трудозатратно будет если проект вайтлейблица. На каждый вайтлебл нужно выполнять по два раза ВСЮ последовательность этих операций, и при этом, не забывая верстать. 
Вайтлейблинг это что-то типо создания скина для сайта, только разные версии сайта могут еще отличаться и функционалом.

### Рутина

И тут нам на помощь опять приходят best practices из мира back-end разработчиков. Каждый уважающий себя фреймворк, добавляющий большое количество шаблонных операций, идет со своим скаффолдером. Для клиентской разработки выбор скаффолдеров невелик. Один из вариантов – это grunt-init, но из коробки он совсем какой-то беспомощный.

### Yo
###### [хип-хоп]

Yo – скаффолдер, работающий под node.js. По этому скаффолдеру написано огромное количество статей, однако все эти статьи грешат тем, что не рассматривают никакого другого приложения кроме как генерации базового проекта.

Безусловно, старт нового проекта также важно автоматизировать, ведь это вполне себе может отнимать до целого дня (особенно если используется очень большой стек технологий). Однако после старта проекта все самое интересно только начинается.

Yo довольно простой в освоении инструмент, написать свой генератор можно за вечер.
Если же выделить на его изучение больше одного вечера, то можно написать генератор для сколько угодно сложного рабочего воркфлоу.


Yo взаимодействует с пользователем по средствам `inquirer.js` он позволяет задавать пользователям различные типы вопросов в плоть то чекбоксов.

Так, например, в нашем генераторе мы можем уточнить у разработчика, для каких вайтлейблов ему нужно добавить сущность динамически.

### Подгенераторы

`$ > yo dx someAwesomeBlock`

`$ > yo dx someAwesomeBlock --styls`

`$ > yo dx someAwesomeBlock --partial`

###### (Показать пример генератора)


### Переиспользование

Говоря о проблеме поддерживаемой верстки, не стоит забвать что различные общие части мужду проектами можно и нужно переиспользовать чтобы при внесение изменений не тратить время разбирайсь как конкретный блок используется в конкретном проекте. Это приводит нас к еще одной важно теме - управление зависимостями
