# Организация кода

Чтобы писать поддерживаемую верстку, в первую очередь нужно грамотно разбивать стили.
Самое главное, не стоит это делать интуитивно. Лучше выработать ряд соглашений по организации файловой структуры ваших стилей. Однако, поддержание подобных соглашений может вызывать кучу негативных моментов.

Чтобы не говорить о сферических конях в вакууме, попробую объяснить на примере соглашений принятых в нашей команде.


Серебряной пули, как организовывать ваши стили, не существует. На вашу файловую структуру должны оказывать влияние идеология разработки и специфика ваших проектов.

Для нас исходные данные были такими
* в качестве идеологии мы используем идеологическую составляющую методологии БЭМ
* а специфика наших проектов такова, что в любой момент проект может обрасти большим количеством различных цветовых схем (или скинов)


Спустя некоторое время мы выработали следующее соглашение для организации кода:
* для каждого скина мы разбиваем стили на `blocks` (стили, отвечающие за поведение блока) и `looks` (стили, отвечающие за внешний вид блока)
* на **каждый** блок мы заводим свою папочку с минимальной структурой
* крупные модификаторы выносим в отдельные файлы в рамках блока
 
Шаблонные операции:

1. Создать файловую раскладку для различных типов стилей
2. зарегистрировать новые файлы и папки в соответствующих `index.styl`
3. толкнуть все новые файлы в VCS

И в принципе это не такая уж и большая проблема для простого проекта, пока он не начинает обрастать новыми цветовыми схемами.


Для активного скинящегося проекта поддержка подобных соглашений будет увеличиваться с каждой новой цветовой схемой.

Удовольствие же от работы с таким проектом пропадет уже на введении второй цветовой схемы. И так с каждым скином, оставляя все меньше человечного в разработчике, превращая его в копипаст-зомби.


Принятие подобных соглашений – это всегда сделка: возможность быстрого внесения изменений за счет дополнительной траты времени на шаблонные операции по созданию файлов и папок.

Причем чем сильнее дробление, тем проще и быстрее вносить изменения, но тем больше времени отнимают различные шаблонные операции по поддержанию файловой структуры.


Чтобы все были счастливы, необходимо свести к минимуму затраты времени на шаблонные операции и сделать это время постоянным (не зависящим от сложности проекта)


Решение своих проблем мы нашли в скаффоолдерах.
Скаффолдер – это CLI утилита (обычно идет с фреймворком), которая по запросу пользователя (разработчика) генерирует шаблонный код и структуру файлов, необходимую для поддержания работы фреймворка.


Для клиентской разработки самый популярный скаффолдер – Yo. Хотя по большому счету это не скаффолдер, а фреймворк, который позволяет создавать свои кастомные скаффолдеры.

* механизм запуска генерации
* логирование
* взаимодействие с пользователем (посредством inquirer.js)
* процессинг файлов

Yo берет на себя всю головную боль, связанную с созданием CLI утлиты: запуск, логирование, взаимодействие с пользователем. 

А также предоставляет возможность создания своего скаффолдера для поддержания сколь угодно сложного рабочего процесса. 
Он даже предоставляет скаффолдер для создания скаффолдеров. В терминах yo кастомный скаффолдер называется генератором

Потратив немного времени, мы реализовали простенький генератор для поддержания своих соглашений.

1. При запуске генератор анализирует проект, находит все цветовые схемы
2. В формате чекбокса запрашивает, для каких цветовых схем нужно создать файлы для блоков

После начинается процесс генерации и генератор: 

1. Генерирует все необходимые файлы
2. Регистрирует все новые созданные файлы
3. Помещает все новые файлы под систему контроля версий


В результате нам удалось оптимизировать наши процессы, существенно снизив затраты времени на поддержание соглашений, оставив все преимущества дробной структуры.


Давайте теперь поговорим об [управлении зависимостями](dependencies.md).
