# Организация кода

Чтобы писать поддерживаемую верстку в первую очередь нужно граммотно разбивать стили.
Самое главное не стоит это делать интуитивно. Лучше выработать ряд соглашений по организации файловой структуры ваших стилей. Однако поддержание подобных соглашений может вызывать кучу негативных моментов.

Чтобы не говорить о сферических конях в вакууме, попробую обьяснить на примере соглашений принятых в нашей команде.

###### <слайд выбор файловой структуры>
Серебренной пули как организовывать ваши стили - не существует. На вашу файловую структуру должны оказывать влияние идеология разработки и специфика ваших проектов.

###### <клик>
Для нас исходные даные были такими
* в качестве иделогии мы используем идеологическую составляющую методологии БЭМ
* а специфика наший проектов такова что в любой момент проект может обрасти большим количеством различных цветовых схем (или скинов)


###### <Слайд с файловой структрой>
Спустя некоторое время мы выработали следующее соглашение для организации кода:
* для каждого скина мы разбиваем стили на `blocks` (стили отвечающие за поведение блока) и `looks` (стили отвечающие за внешний вид блока)
* на **каждый** блок мы заводим свою папочку с минимальной структурой
* крупные модификаторы выносим в отдельные файлы в рамках блока
 
Шаблонные операции:

1. Создать файловую раскладку для различных типов стилей
2. зарегистрировать новые файлы и папки в соответсвующих `index.styl`
3. толкнуть все новые файлы в VCS

И впринципи это не такая уж и большая проблема для простого проекта пока он не начинает обрастать новыми цветовыми схемами.


Для активного скинящегося проекта поддержка подобных соглашений будет увеличиваться с каждой новой цветовой схемой.

Удвовльствие же от работы с таким проектом пропадет уже на введении второй цветовой схемы. И так далее, с каждым скином оставляя все меньше человечного в разработчике, превращая его в копипаст-зомби.


Принятие подобных соглашений это всегда сделка: возможность быстрого внесения изменений за счет дополнительной траты времени на шаблонные операции по созданию файлов и папок.

Причем чем сильнее дробление тем проще и быстрее вносить изменения, но тем больше времени отнимают различные шаблонные операции по поддержанию файловой структуры.


Чтобы все были счастливы необходимо свести к минимуму времязатраты на шаблонные операции и сделать это время постоянным (не зависящим от сложности проекта)


Решение своих проблем мы нашли в скаффоолдерах.
Скаффолдер - это CLI утилита (обычно идет с фреймворком), которая по запросу пользователя (разработчика) генерирует шаблонный код и структуру файлов необходимую для поддержания работы фреймворка.


Для клиентской разработки самый популярный скаффолдер - Yo. Хотя по большому счету это не скаффолдер, а фреймворк который позволяет создавать свои кастомные скаффолдеры.

* механизм запуска генрации
* логгирование
* взаимодействие с пользователем (по средствам inquirer.js)
* процессинг файлов

Yo берет на себя всю головную боль связанную с созданием CLI утлиты: запуск, логгирование, взаимодействие с пользователем. 

А также пердоставляет возможность создания своего скаффолдера для поддержания сколь угодно сложного рабочего процесса. 
Он даже предоставляет скаффолдер для создания скаффолдеров. В терминах yo кастомны скаффолдер называется генератором

Потратив немного времени мы реализовали простенький генератор для поддержания своих соглашений.

1. При запуске генератор анализирует проект, находит все цветовые схемы
2. В формате чекбокса запрашивает для каких цветовых схем нужно создать файлы для блоков

После начинается процесс генерации и генератор: 

1. Генерирует все необходимые файлы
2. Регестрирует все новые созданные файлы
3. Помещает все новые файлы под систему контроля версий


В результате нам удалось оптимизирвоать наши процессы, существенно снизив времязатраты на поддержание соглашений, оставив все приемущества дробной структуры.
